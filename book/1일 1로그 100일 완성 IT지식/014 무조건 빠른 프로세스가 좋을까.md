
## 프로세서는 인출, 해석 실행 사이클을 계속 반복 수행
__***인출***__ - 메모리에서 다음에 처리할 명령어를 인출  

__***해석***__ - 이어서 가져온 명령어 해석(보통 다음 메모리 위치에 저장된 명령어 또는 GOTO나 IFZELO 명령어일 수도 있다.) 
> 🗸 즉 해석은 명령어를 수행하는데 필요한 모든 준비를 마치는 것을 의미  

__***실행***__ - 메모리에서 정보를 가져오고, 산술연산 또는 논리 연산을 수행하고 결과를 저장하는 명령어에 따라 적절한 조합으로 이루어짐

```
⭐️ 실제 프로세서는 인출, 해석, 실행 사이클에는 정교한 메커니즘이 사용되만 간단한 루프에 불과하다고 합니다.  그리고
 보통 수십 개에서 수백 개의 명령어가 있고, 명령어와 데이터는 여러 개의 메모리 위치를 2~8바이트정도 차지한다.
 
 실제 프로세서에는 누산기가 여러개(보통 16개 또는 32개) 있어서, 초고속 메모리 역활을 하는 누산기에 중간 결과를 하나 이상 담을 수 있다.
 또는 앞서 나왔던 모형 컴퓨터 예제에 비하면 방대하며, 흔히 명령어 수백만 개로 이루어진다.
```

## 프로세서의 속도
- 프로세서는 속도는 매우 빨라서 명령어 한 개를 1나노초보다 훨씬 더 짧은 시간 내에 수행한다.
> 👉🏾 나노가 10억분의 1
- 그에 비해 메모리는 몹시 느리다.
> 👉🏾 데이터와 명령어를 메모리에서 인출하는데 10~20 나노초 정도 걸린다. 물론 절대적으로는 빠르지만, 프로세서 관점에서는 느리다
```
⭐️ 현대 컴퓨터 아키텍처는 캐시라는 고속 메모리를 사용하는데 캐시는 프로세서와 메모리
   사이에 있고 최근 사용된 명령어와 데이터를 담고 있다. 캐시에서 찾을 수 있는 정보에 접근하는 편이
   메모리에서 정보가 오기를 기다리는 것보다 빠르다.
```

# 여러가지 아키텍처
__***첫번째***__ - 인출과 실행 단계가 겹치도록 프로세서를 설계하는 기법(파이프라이닝)
> 👉🏾 명령어 여러 개가 다양한 단계에 걸처 진행되도록, 즉 명령어 한 개가 완료되는 데는 여전히 같은 시간이 걸리지만, 여러 개의 명령어를 동시에 처리하므로 전체적인 처리 속도는 빨라진다.  


__***두번째***__ 명령어들이 서로 간섭하거나 의존하지 않는다면 다수의 명령어를 병렬적으로 실행하는 기법
> 👉🏾 차량 생산에 비유하자면 병령 조립 라인을 사용하는 것과 비슷  


__***세번째***__ 프로세서 여러 개가 동시에 작업하도록 하는 기법
> 👉🏾 오늘날의 노트북과 휴대전화에서 표준으로 사용되는 기술 
> 👉🏾 직접회로의 선폭이 작아질수록 칩에 트랜지스터를 더많이 넣을 수 있는데 보통 더 많은 코어와 캐시메모리를 넣는데 사용된다.  


## 사용분야에 따른 프로세서 설계
__***데스크탑***__     
> 👉🏾 전력이 충분, 물리적 공간이 비교적 넉넉함해서 팬으로 열을 분산이 가능 - 프로세서를 가능한 한 빨리작동하도록 집중  

__***노트북 ***__  

> 👉🏾 물리적 공간이 협소, 무겁고 비싼 배터리에서 전력을 공급 - 전력을 적게 사용하도록 특별히 설계된 방식의 프로세서 적용

```
⭐️ 가능한 한 빨리작동하도록 집중한 프로세서에서 전력을 적게 사용하도록 수정하는 것은 기존 설계를 약간 수정하는 것으로는 불충분하다.
    완전히 다르게 설계된 프로세서이기 때문에 일대일로 비교하기 어려울 만큼 다른 방식으로 처리되기도한다. 
    
    예를 들면 
    👉🏾 같은 기능이지만 명령어 개수가 다를 수도 있고,  전력 소모를 낮추고자 빠른 실행 속도를 포기하기도한다.
```

## 결론
- 어떤 프로세서가 다른 것보다 빠르다는 주장은 조심스럽게 받아들여야 하고 요구사항에 따라 차이가 있을 수 있다.





 



